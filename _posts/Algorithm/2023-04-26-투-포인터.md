---
layout: post
title:  "[Algorithm] 3. 투 포인터"

categories: Algorithm
---

<br>

## 투 포인터

<br>

일반적으로 배열이나 리스트에서 조건에 맞는 두 값을 찾을 때 이중 for문을 이용합니다.

$N$개의 길이를 가진 배열 또는 리스트를 이중 for문을 이용해 탐색하면 $O(N^{2})$의 시간 복잡도를 가집니다.

$O(N^{2})$의 시간 복잡도가 문제의 제한 된 시간을 초과 할 경우가 생깁니다.

이러한 경우 투 포인터를 이용하여 문제를 해결할 수 있습니다. 투 포인터는 시간 복잡도가 $O(N)$으로 나옵니다.

<br>

1차원 배열 또는 리스트에서 두개의 포인터(커서)를 이용하여 문제를 풀이합니다.

<br>

***

<br>

| Index | 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|---|
|value| 5 | 2 | 1 | 2 | 3 |

<br>

위와 같은 배열이 존재할 때, 연속 된 부분 수열의 합이 5가 되는 경우를 찾아봅시다.

<br>

### 일반적 풀이

<br>

일반적인 방법으로는 이중 for문을 이용합니다.

```java
// ...

int[] arr = {5, 2, 1, 2, 3};
int sum = 0, count = 0;

for(int i = 0; i < 5; i++) {
    for(int j = i; j < 5; j++) {
        sum += arr[j];
        if(sum == 5) {
            count++;
            break;
        }
    }
}

// ...
```

위 풀이의 시간 복잡도는 $O(N^{2})$입니다.

<br>

***

<br>

### 투 포인터를 이용한 풀이

<br>

| Index | 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|---|
|value| 5 | 2 | 1 | 2 | 3 |
|start| ^ | | | | |
| end | ^ | | | | |

start, end 두 포인터를 인덱스 0에 위치 시킵니다.

위의 경우에는 합이 5인 조건에 맞는 수열입니다.

다음 수열에서의 합의 값을 알기 위해 합이 초과되지 않은 경우 end 포인터를 오른쪽으로 한 칸 이동합니다.

<br>

**step 1**

| Index | 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|---|
|value| 5 | 2 | 1 | 2 | 3 |
|start| ^ | | | | |
| end | | ^ | | | |

sum = 7

<br>

step1에서 end 포인터를 이동 후 더하면 값이 5가 초과 됩니다.

합이 초과 되는 경우에는 start를 오른쪽으로 이동합니다.

<br>

**step 2**

| Index | 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|---|
|value| 5 | 2 | 1 | 2 | 3 |
|start| | ^| | | |
| end | | ^| | | |

sum = 2

<br>

위처럼 합이 초과 되지 않는 경우는 계속하여 end 포인터를 이동해 줍니다.

<br>

**step 3**

| Index | 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|---|
|value| 5 | 2 | 1 | 2 | 3 |
|start| | ^| | | |
| end | | |^| | |

sum = 3

<br>

**step 4**

| Index | 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|---|
|value| 5 | 2 | 1 | 2 | 3 |
|start| | ^| | | |
| end | | | |^ | |

sum = 5

<br>

위의 경우도 부분 수열의 합이 5가 되는 경우입니다.

<br>

**step 5**

| Index | 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|---|
|value| 5 | 2 | 1 | 2 | 3 |
|start| | ^| | | |
| end | | | ||^|

sum = 8

<br>

합이 8로 초과되었으므로 start를 이동해 줍니다.

<br>

**step 6**

| Index | 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|---|
|value| 5 | 2 | 1 | 2 | 3 |
|start| | | ^| | |
| end | | | ||^ |

sum = 6

<br>

**step 7**

| Index | 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|---|
|value| 5 | 2 | 1 | 2 | 3 |
|start| | | |^| |
| end | | | | |^|

sum = 5

마찬가지로 부분 수열의 합이 5가 되는 경우입니다.

<br>

**step 8**

| Index | 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|---|
|value| 5 | 2 | 1 | 2 | 3 |
|start| | | ||^|
| end | | | | |^|

sum = 3

이렇게 두개의 포인터로 마지막 경우의 수까지 탐색할 수 있습니다.

해당 시간 복잡도는 하나의 포인터당 N번을 거치므로 $N+N = 2N$. 즉, $O(N)$의 시간 복잡도를 가지게 됩니다.

코드로는 밑과 같이 풀이가 가능합니다.

```java
// ...

int[] arr = {5, 2, 1, 2, 3};
int end = 0;
int sum = 0, count = 0;

for(int start = 0; start < 5; start++) {
    while(end < 5) {
        sum += arr[end];
        if(sum > 5) {
            sum -= arr[end];
            break;
        }
        else if(sum == 5)    count++;
        end++;
    }

    sum -= arr[start];
}

// ...
```