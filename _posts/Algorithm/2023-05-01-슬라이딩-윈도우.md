---
layout: post
title:  "[Algorithm] 4. 슬라이딩 윈도우"

categories: Algorithm
---

<br>

## 슬라이딩 윈도우

<br>

두 개의 포인터를 이용한 것은 투 포인터와 같으나, 차이점은 슬라이딩 윈도우는 고정 된 구간으로 두 포인터가 이동하는 것입니다.

투 포인터와 마찬가지로 슬라이딩 윈도우는 시간 복잡도가 $O(N)$으로 나옵니다.

<br>

1차원 배열 또는 리스트에서 두개의 포인터(커서)를 이용하여 고정된 길이를 유지하며 이동하여 문제를 풀이합니다.

<br>

***

<br>

| Index | 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|---|
|value| 5 | 2 | 1 | 2 | 3 |

<br>

위와 같은 배열이 존재할 때, 연속 된 길이 3의 부분 수열의 합이 5가 되는 경우를 찾아봅시다.

<br>

***

<br>

<br>

### 일반적 풀이

<br>

일반적인 방법으로는 이중 for문을 이용합니다.

```java
// ...

int[] arr = {5, 2, 1, 2, 3};
int k = 3, count = 0;

// 직접 i ~ j의 위치를 다 더하여 조건을 본다.
for(int i = 0; i < 5 - k + 1; i++) {
    int sum = 0;
    for(int j = i; j < i + k; j++) {
        sum += arr[j];
    }
    if(sum == 5) {
        count++;
        break;
    }
}

// ...
```

위 풀이의 시간 복잡도는 $O(N^{2})$입니다.

<br>

***

<br>

### 슬라이딩 윈도우를 이용한 풀이

<br>

| Index | 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|---|
|value| 5 | 2 | 1 | 2 | 3 |
|start| ^ | | | | |
| end | | |^| |

sum = 8

start를 0, end를 길이 3에 해당도록 2에 위치 시킵니다.

위의 경우에는 합이 8로 조건에 맞지 않아 start, end 둘 다 오른쪽으로 한칸씩 이동합니다.

<br>

**step 1**

| Index | 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|---|
|value| 5 | 2 | 1 | 2 | 3 |
|start| | ^ | | | |
| end | | | | ^ | |

sum = 5

<br>

step1에서 start, end 포인터를 이동 후의 합은 5가 됩니다.

해당 경우는 조건에 맞는 경우입니다.

<br>

**step 2**

| Index | 0 | 1 | 2 | 3 | 4 |
|---|---|---|---|---|---|
|value| 5 | 2 | 1 | 2 | 3 |
|start| | | ^ | | |
| end | | | | | ^ |

sum = 6

<br>

위처럼 end가 끝에 닿을 때 까지 start, end를 이동하여 길이 3의 부분수열의 합을 볼 수 있습니다.

<br>

해당 시간 복잡도는 하나의 포인터당 N번을 거치므로 $N - M$. 즉, $O(N)$의 시간 복잡도를 가지게 됩니다.

코드로는 밑과 같이 풀이가 가능합니다.

<br>

```java
// ...

int sum = 0, k = 4, window = 0;

for(int i = 0; i < 5; i++) {
    // 더한 후에 슬라이딩 윈도우 길이보다 커지면 앞의 값을 빼준다
    sum += arr[window++];

    if(window >= k) {
        sum -= arr[i - k + 1];
        if(sum == 5)    count++;
    }
}

// ...
```